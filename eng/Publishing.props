<Project>
  <PropertyGroup>
    <!-- Since Arcade SDK's AfterSigning.proj file does not import the Arcade SDK, this
         setting is necessary because we are manually importing the Arcade SDK targets
         below in order to get the GenerateChecksums target. -->
    <_SuppressSdkImports>false</_SuppressSdkImports>
    <PublishingVersion>3</PublishingVersion>
  </PropertyGroup>

  <PropertyGroup>
    <BundleOutputDir>$(ArtifactsDir)bundledtools/</BundleOutputDir>
    <PublishDependsOnTargets>$(PublishDependsOnTargets);CollectBundledToolsArchives;CollectPackageArtifactFiles</PublishDependsOnTargets>
  </PropertyGroup>

  <ItemGroup>
    <PackageFile Include="$(ArtifactsShippingPackagesDir)**/*.nupkg" IsShipping="true" />
    <PackageFile Include="$(ArtifactsNonShippingPackagesDir)**/*.nupkg" IsShipping="false" />
    <FilesToPublishToSymbolServer Include="$(BundleOutputDir)**/*.pdb" />
    <BundledToolsArchives Include="$(BundleOutputDir)**/*.zip" />
  </ItemGroup>

  <Target Name="CollectBundledToolsArchives">
    
    <!-- To dissambiguate the blob links generated by subsequent builds
    by using a build version, preferable related to the tool being published.
    Publish.proj - which imports this file - doesn't import the files in
    Microsoft.DotNet.Arcade.SDK needed to get a version. This queries a project
    to get it; dotnet-trace is a random choice as all tools share the same version.
    Once we stabilize dotnet-monitor, we might need to start calling this target
    on every tool that needs publishing. -->
    <MSBuild Projects="$(RepoRoot)src/Tools/dotnet-trace/dotnet-trace.csproj"
        Targets="_GetPackageVersionInfo"
        SkipNonexistentProjects="false">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedPackageVersionInfo" />
    </MSBuild>

    <PropertyGroup>
      <_PackageVersion>@(_ResolvedPackageVersionInfo->'%(PackageVersion)')</_PackageVersion>
    </PropertyGroup>

    <ItemGroup>
      <ItemsToPushToBlobFeed Include="@(BundledToolsArchives)">
        <IsShipping>true</IsShipping>
        <PublishFlatContainer>true</PublishFlatContainer>
        <RelativeBlobPath>diagnostics/bundledtools/$(_PackageVersion)/%(FileName)%(Extension)</RelativeBlobPath>
        <ManifestArtifactData>Category=OTHER</ManifestArtifactData>
      </ItemsToPushToBlobFeed>
    </ItemGroup>

  </Target>

  <Target Name="GenerateChecksumsForBlobgroups">
    <ItemGroup>
      <GenerateChecksumItems Include="%(PackageFile.Identity)"
                             Condition="$([System.IO.File]::Exists('%(PackageFile.Identity).blobgroup'))" >
        <DestinationPath>%(FullPath).sha512</DestinationPath>
      </GenerateChecksumItems>
    </ItemGroup>

    <GenerateChecksums Items="@(GenerateChecksumItems)" />
  </Target>

  <!-- Run the CollectPackageArtifactFiles target on each PackageFile by target batching on a non-existing file.
       This allows using the ReadLinesFromFile task to read the blob group file, which was written with WriteLinesToFile,
       thus avoiding erroneously reading in the newline at the end of the blob group file. -->
  <Target Name="CollectPackageArtifactFiles"
          DependsOnTargets="GenerateChecksumsForBlobgroups"
          Inputs="@(PackageFile)"
          Outputs="%(PackageFile.Identity).notexist">

    <!-- Find the artifact files next to the package file. -->
    <PropertyGroup>
      <_BlobGroupFilePath>%(PackageFile.FullPath).blobgroup</_BlobGroupFilePath>
      <_ChecksumFilePath>%(PackageFile.FullPath).sha512</_ChecksumFilePath>
      <_VersionFilePath>%(PackageFile.FullPath).version</_VersionFilePath>
    </PropertyGroup>

    <Error Condition="Exists('$(_BlobGroupFilePath)') and !Exists('$(_ChecksumFilePath)')"
        Text="Expected SHA512 hash for %(PackageFile.FullPath) not found at $(_ChecksumFilePath)"/>

    <!-- Read in blob group name, if it exists -->
    <ReadLinesFromFile File="$(_BlobGroupFilePath)" Condition="Exists('$(_BlobGroupFilePath)')">
      <Output TaskParameter="Lines" PropertyName="_BlobGroupName"/>
    </ReadLinesFromFile>

    <!-- Calculate manifest artifact data for each file type. -->
    <ItemGroup>
      <_CommonArtifactData Include="NonShipping=true" Condition="'%(PackageFile.IsShipping)' != 'true'" />
    </ItemGroup>
    <ItemGroup>
      <_PackageArtifactData Include="@(_CommonArtifactData)" />
      <!-- Setting Category to Other will upload to installers blob feed. -->
      <!-- Feed configuration categories are uppercase and case sensitive in PublishArtifactsInManifest task. -->
      <_PackageArtifactData Include="Category=OTHER" />
    </ItemGroup>

    <!-- Capture each blob item to upload to blob feed -->
    <ItemGroup>
      <_BlobItem Include="%(PackageFile.FullPath)">
        <ManifestArtifactData>@(_PackageArtifactData)</ManifestArtifactData>
      </_BlobItem>
      <_BlobItem Include="$(_ChecksumFilePath)" Condition="Exists('$(_ChecksumFilePath)')">
        <ManifestArtifactData Condition="'@(_CommonArtifactData)' != ''">@(_CommonArtifactData)</ManifestArtifactData>
      </_BlobItem>
      <_BlobItem Include="$(_VersionFilePath)" Condition="Exists('$(_VersionFilePath)')">
        <ManifestArtifactData Condition="'@(_CommonArtifactData)' != ''">@(_CommonArtifactData)</ManifestArtifactData>
      </_BlobItem>
    </ItemGroup>

    <!-- Add artifact items to be pushed to blob feed -->
    <ItemGroup>
      <ItemsToPushToBlobFeed Include="@(_BlobItem)" Condition="'$(_BlobGroupName)' != ''">
        <RelativeBlobPath>diagnostics/$(_BlobGroupName)/%(_BlobItem.Filename)%(_BlobItem.Extension)</RelativeBlobPath>
        <PublishFlatContainer>true</PublishFlatContainer>
      </ItemsToPushToBlobFeed>
    </ItemGroup>
  </Target>

  <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
</Project>
