parameters:
  # Job name
- name: name
  type: string
  default: ''

- name: jobTemplate
  type: string
  default: /eng/common/templates-official/job/job.yml@self
  values:
  - /eng/common/templates-official/job/job.yml@self
  - /eng/common/templates/job/job.yml@self

- name: osGroup
  type: string
  default: Windows_NT
  values:
  - Windows_NT
  - Linux
  - MacOS
  - FreeBSD

- name: osSuffix
  type: string
  default: ''

  # Additional variables
- name: variables
  type: object
  default: {}

  # Optional: Job timeout
- name: timeoutInMinutes
  type: number
  default: 180

  # Optional: Build container to use
- name: templateContext
  type: object
  default: {}

# Build configs. An object with the following properties: configuration, architecture.
# Optionally it can also contain artifactUploadPath, artifactTargetPath
- name: buildConfigs
  type: object
  default: {}

  # Optional: container resource name
- name: container
  type: string
  default: ''

  # Optional: build only, skip tests
- name: buildOnly
  type: boolean
  default: false

# Optional: architecture cross build if true
- name: crossBuild
  type: boolean
  default: false

- name: isCodeQLRun
  type: boolean
  default: false

- name: disableComponentGovernance
  type: boolean
  default: false

  # Send tests to Helix for distributed execution
- name: useHelix
  type: boolean
  default: false

  # Helix queue to target (required when useHelix is true)
- name: helixQueues
  type: string
  default: ''

  # Whether this is an official (non-PR, internal) build
- name: isOfficialBuild
  type: boolean
  default: false

jobs:
- ${{ each config in parameters.buildConfigs }}:
  - template: ${{ parameters.jobTemplate }}
    parameters:
      name: ${{ coalesce(parameters.name, parameters.osGroup) }}_${{ config.architecture }}_${{ config.configuration }}
      timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
      enableMicrobuild: true
      runAsPublic: ${{ parameters.isCodeQLRun }}
      disableComponentGovernance: ${{ parameters.disableComponentGovernance }}
      templateContext: ${{ parameters.templateContext }}

      pool:
        # Public Linux Build Pool
        ${{ if eq(parameters.osGroup, 'Linux') }}:
          name: $(BuildPool)
          demands: ImageOverride -equals $(LinuxImage)
          os: linux

        ${{ elseif eq(parameters.osGroup, 'Windows_NT') }}:
          name: $(BuildPool)
          demands: ImageOverride -equals $(WindowsImage)
          os: windows

        ${{ elseif in(parameters.osGroup, 'MacOS') }}:
          name: Azure Pipelines
          vmImage: $(macOSImage)
          os: macOS

        ${{ elseif and(eq(parameters.osGroup, 'FreeBSD'), ne(variables['System.TeamProject'], 'public')) }}:
          name: dnceng-freebsd-internal
          os: freebsd

        ${{ else }}:
          'error, Unable to identify pool for required build': error

      ${{ if ne(parameters.container, '') }}:
        container: ${{ parameters.container }}

      ${{ if ne(parameters.strategy, '') }}:
        'error, we can no longer support the strategy feature in the new pipeline system. Please remove the strategy from the job template.': error

      workspace:
        clean: all

      variables:
      - ${{ insert }}: ${{ parameters.variables }}

      - _PhaseName: ${{ coalesce(parameters.name, parameters.osGroup) }}_${{ config.architecture }}_${{ config.configuration }}
      - _Pipeline_StreamDumpDir: $(Build.SourcesDirectory)/artifacts/tmp/${{ config.configuration }}/streams

      - _Cross: ''

      - ${{ if eq(parameters.osGroup, 'Windows_NT') }}:
        - _buildScript: $(Build.SourcesDirectory)\build.cmd
      - ${{ if ne(parameters.osGroup, 'Windows_NT') }}:
        - _buildScript: $(Build.SourcesDirectory)/build.sh

      # For testing msrc's and service releases. The RuntimeSourceVersion is either "default" or the service release version to test
      - _InternalInstallArgs: ''
      - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(parameters.isCodeQLRun, 'false')) }}:
        - _InternalInstallArgs:
            -dotnetruntimeversion '$(DotnetRuntimeVersion)'
            -dotnetruntimedownloadversion '$(DotnetRuntimeDownloadVersion)'
            -runtimesourcefeed '$(RuntimeFeedUrl)'
            -runtimesourcefeedkey '$(RuntimeFeedBase64SasToken)'

      # This is only required for cross builds.
      - ${{ if eq(parameters.crossBuild, true) }}:
        - _Cross: -cross

      # Helix variable group (only when useHelix is true, for official builds)
      - ${{ if and(eq(parameters.useHelix, true), eq(parameters.isOfficialBuild, true)) }}:
        - group: DotNet-HelixApi-Access

      steps:
      - ${{ if eq(parameters.isCodeQLRun, 'true') }}:
        - task: CodeQL3000Init@0
          displayName: CodeQL Initialize

      - script: $(_buildScript)
          -ci
          -binaryLog
          -configuration ${{ config.configuration }}
          -architecture ${{ config.architecture }}
          $(_Cross)
          $(_InternalInstallArgs)
          /p:OfficialBuildId=$(BUILD.BUILDNUMBER)
        displayName: Build
        condition: succeeded()

      - ${{ if eq(parameters.isCodeQLRun, 'true') }}:
        - task: CodeQL3000Finalize@0
          displayName: CodeQL Finalize

      # Send tests to Helix (when useHelix is true and not buildOnly)
      - ${{ if and(eq(parameters.useHelix, true), ne(parameters.buildOnly, true)) }}:
        - template: /eng/pipelines/send-to-helix.yml@self
          parameters:
            configuration: ${{ config.configuration }}
            architecture: ${{ config.architecture }}
            osGroup: ${{ parameters.osGroup }}
            osSuffix: ${{ parameters.osSuffix }}
            helixQueues: ${{ parameters.helixQueues }}
            isOfficialBuild: ${{ parameters.isOfficialBuild }}

      - ${{ if ne(config.artifactUploadPath, '') }}:
        - task: CopyFiles@2
          displayName: Gather binaries for publish
          inputs:
            SourceFolder: '$(Build.SourcesDirectory)/artifacts/${{ config.artifactUploadPath }}'
            Contents: '**'
            TargetFolder: $(Build.ArtifactStagingDirectory)/artifacts/${{ coalesce(config.artifactTargetPath, config.artifactUploadPath) }}

        - template: /eng/pipelines/publish-pipeline-artifact-shim.yml@self
          parameters:
            displayName: Publish Build Artifacts
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/artifacts'
              artifactName: Build_$(_PhaseName)

      - task: CopyFiles@2
        displayName: Gather diagnostic artifacts on failure
        inputs:
          SourceFolder: '$(Build.SourcesDirectory)/artifacts'
          TargetFolder: $(Build.ArtifactStagingDirectory)/artifacts_on_failure
          Contents: |
            bin/**
            log/**
            TestResults/**
            tmp/${{ config.configuration }}/dumps/**
            tmp/${{ config.configuration }}/streams/**
        continueOnError: true
        condition: failed()

      - template: /eng/pipelines/publish-pipeline-artifact-shim.yml@self
        parameters:
          displayName: Publish diagnostic artifacts on failure
          inputs:
            targetPath: $(Build.ArtifactStagingDirectory)/artifacts_on_failure
            artifactName: Artifacts_On_Failure_$(_PhaseName)_$(System.JobAttempt)
            sbomEnabled: false # we don't need SBOM for non-shipping diagnostics assets
          continueOnError: true
          condition: failed()

      - task: CopyFiles@2
        displayName: Gather Logs
        inputs:
          sourceFolder: '$(Build.SourcesDirectory)/artifacts'
          contents: '?(log|TestResults)/**'
          targetFolder: '$(Build.StagingDirectory)/BuildLogs'
        continueOnError: true
        condition: always()

      - template: /eng/pipelines/publish-pipeline-artifact-shim.yml@self
        parameters:
          displayName: Publish Logs
          inputs:
            targetPath: '$(Build.StagingDirectory)/BuildLogs'
            artifactName: Logs_$(_PhaseName)_$(System.JobAttempt)
            sbomEnabled: false # we don't need SBOM for logs
          continueOnError: true
          condition: always()
